# 2. 도메인 분석 설계
## 03. 엔티티 클래스 개발
> 예제와 다르게 실무에서는 가급적 Getter는 열어두고, Setter는 꼭 필요한 경우에만 사용하는 것을 추천한다.
> Stter를 막 열어두면 가까운 미래에 엔티티가 도대체 왜 변경되는지 추적하기 점점 힘들어진다.
> 그래서 엔티티를 변경할 때는 Setter 대신에 변경 지점이 명확하도록 변경을 위한 비즈니스 메서드를 별도로 제공해야 한다.

![image](https://github.com/GYUNGAEEEE/inflearn-SpringBoot-JPA/assets/158580466/941e8109-f442-40f5-87c7-7f1ee24d0ace)
#### 회원 엔티티
```java
@Entity
@Getter @Setter
public class Member {

    @Id @GeneratedValue
    @Column(name = "member_id")
    private Long id;

    private String name;

    @Embedded
    private Address address;

    @OneToMany(mappedBy = "member")
    private List<Order> orders = new ArrayList<>();
}
```
엔티티의 식별자는 id를 사용하고 PK 컬럼명은 member_id를 사용했다.
엔티티는 타입이 있으므로 id 필드만으로 쉽게 구분할 수 있으나(ex. member.id), 테이블은 타입이 없으므로 구분이 어렵기 때문이다.
그리고 관례상 테이블명 + id 를 많이 사용한다. 물론 객체에서 id 대신에 memberId를 사용해도 된다. 중요한 것은 일관성이다.

#### 주문 엔티티
```java
@Entity
@Table(name = "orders")
@Getter @Setter
public class Order {

    @Id @GeneratedValue
    @Column(name = "order_id")
    private Long id;

    @ManyToOne
    @JoinColumn(name = "member_id")
    private Member member;

    @OneToMany(mappedBy = "order")
    private List<OrderItem> orderItems = new ArrayList<>();

    @OneToOne
    @JoinColumn(name = "delivery_id")
    private Delivery delivery;

    private LocalDateTime orderDate; //주문시간

    @Enumerated(EnumType.STRING)
    private OrderStatus status; //주문상태 [ORDER, CANCEL]
}
```
#### 주문 상태
```java
public enum OrderStatus {
    ORDER, CENCEL
}
```
@Enumerated 애노테이션 종류에는 EnumType.STRING과 EnumType.ORIGINAL이 있다.
ORIGINAL의 경우 enum 순서(숫자) 값을 DB에 저장하고(1, 2, ...), STRING의 경우 enum 이름 값을 DB에 저장한다.

그런데, ORIGINAL의 경우 값을 중간에 추가하게 되면 순서가 밀리기 때문에 기존의 코드와 섞일 수 있다.
따라서, EnumType.STRING을 사용하는 것이 좋다.
### 주문 상품
```java
@Entity
@Getter @Setter
public class OrderItem {

    @Id @GeneratedValue
    @Column(name = "order_item_id")
    private Long id;

    @ManyToOne
    @JoinColumn(name = "item_id")
    private Item item;

    @ManyToOne
    @JoinColumn(name = "order_id")
    private Order order;

    private int orderPrice; //주문 가격
    private int count; //주문 수량
}
```
### 상품 엔티티
```java
@Entity
@Inheritance(strategy = InheritanceType.SINGLE_TABLE)
@DiscriminatorColumn(name = "dtype")
@Getter @Setter
public abstract class Item {

    @Id @GeneratedValue
    @Column(name = "item_id")
    private Long id;

    private String name;
    private int price;
    private int stockQuantity;

    @ManyToMany(mappedBy = "items")
    private List<Category> categories = new ArrayList<>();
}
```
### 상품 - 도서 엔티티
```java
@Entity
@Getter @Setter
@DiscriminatorValue("B")
public class Book extends Item {

    private String author;
    private String idbn;
}
```
### 상품 - 음반 엔티티
```java
@Entity
@Getter @Setter
@DiscriminatorValue("A")
public class Album extends Item {

    private String artist;
    private String etc;
}
```
### 상품 - 영화 엔티티
```java
@Entity
@Getter @Setter
@DiscriminatorValue("M")
public class Movie extends Item {

    private String director;
    private String actor;
}
```
상품 엔티티에서는 상속 매핑을 사용하고 있다.

상속 전략을 정의하고 있는 @Inheritance(strategy = InheritanceType.SINGLE_TABLE) 는
하나의 테이블에 상속 관계에 있는 모든 엔티티를 저장한다.
- 모든 엔티티를 하나의 테이블에 저장하므로 조인이 필요 없어서 조회 성능이 좋다.
- 테이블에 모든 속성을 포함하므로, null 값이 많아질 수 있다.
- 각 엔티티 유형을 구분하기 위해 하나의 추가 컬럼이 필요하다.

엔티티의 타입을 구분하는 데 사용되는 컬럼을 정의한 것이 @DiscriminatorColumn(name = "dtype") 이다.
그리고, 서브클래스를 구분하기 위해 사용하는 값을 지정하기위해 @DiscriminatorValue("B") 등을 사용하고 있다.
#### 배송 엔티티
```java
@Entity
@Getter @Setter
public class Delivery {

    @Id @GeneratedValue
    @Column(name = "delivery_id")
    private Long id;

    @OneToOne(mappedBy = "delivery")
    private Order order;

    @Embedded
    private Address address;

    @Enumerated(EnumType.STRING)
    private DeliveryStatus status; //READY, COMP
}
```
#### 배송 상태
```java
public enum DeliveryStatus {
    READY, COMP
}
```
